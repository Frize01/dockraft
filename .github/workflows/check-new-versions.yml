# .github/workflows/check-versions.yml
name: üîç Check Minecraft Versions

on:
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check all APIs
        id: check
        run: |
          if [ ! -f versions.json ]; then
            echo '{}' > versions.json
          fi

          # Sauvegarder l'√©tat AVANT les modifications
          cp versions.json versions.json.bak

          CHANGES=""
          LAGGING=""
          MINOR_UPDATES=""
          HAS_NEW=false

          # ============================================
          # Fonction compare (mutuellement exclusif)
          # ============================================
          compare() {
            local key="$1"
            local new_val="$2"
            local old_val
            old_val=$(jq -r ".${key} // empty" versions.json.bak)

            if [ "$new_val" != "$old_val" ] && [ -n "$new_val" ]; then
              jq --arg k "$key" --arg v "$new_val" '.[$k] = $v' versions.json > versions.json.tmp
              mv versions.json.tmp versions.json
              HAS_NEW=true
            fi
          }

          # ============================================
          # 1. Vanilla & Snapshot
          # ============================================
          echo "::group::Checking Vanilla"
          MANIFEST=$(curl -fsSL https://piston-meta.mojang.com/mc/game/version_manifest_v2.json)
          VANILLA=$(echo "$MANIFEST" | jq -r '.latest.release')
          SNAPSHOT=$(echo "$MANIFEST" | jq -r '.latest.snapshot')
          OLD_VANILLA=$(jq -r '.vanilla // empty' versions.json.bak)

          VANILLA_CHANGED=false
          if [ "$VANILLA" != "$OLD_VANILLA" ] && [ -n "$OLD_VANILLA" ]; then
            VANILLA_CHANGED=true
            echo "üÜï Vanilla: ${OLD_VANILLA} ‚Üí ${VANILLA}"
          else
            echo "‚úÖ Vanilla inchang√©: ${VANILLA}"
          fi

          compare "vanilla"  "$VANILLA"
          compare "snapshot" "$SNAPSHOT"
          echo "::endgroup::"

          # ============================================
          # 2. Paper
          # ============================================
          echo "::group::Checking Paper"
          PAPER=""

          PAPER_BUILDS=$(curl -fsSL \
            "https://api.papermc.io/v2/projects/paper/versions/${VANILLA}/builds" 2>/dev/null || echo "{}")
          PAPER_BUILD=$(echo "$PAPER_BUILDS" | jq -r '.builds[-1].build // empty')

          if [ -n "$PAPER_BUILD" ]; then
            PAPER="${VANILLA}-build.${PAPER_BUILD}"
            if [ "$VANILLA_CHANGED" = true ]; then
              CHANGES="${CHANGES}paper,"
              echo "‚úÖ Paper supporte ${VANILLA} ‚Üí build ${PAPER_BUILD}"
            else
              MINOR_UPDATES="${MINOR_UPDATES}paper,"
              echo "üîß Paper update mineur ‚Üí build ${PAPER_BUILD}"
            fi
          elif [ "$VANILLA_CHANGED" = true ]; then
            LAGGING="${LAGGING}paper,"
            OLD_BUILDS=$(curl -fsSL \
              "https://api.papermc.io/v2/projects/paper/versions/${OLD_VANILLA}/builds" 2>/dev/null || echo "{}")
            OLD_BUILD=$(echo "$OLD_BUILDS" | jq -r '.builds[-1].build // empty')
            if [ -n "$OLD_BUILD" ]; then
              PAPER="${OLD_VANILLA}-build.${OLD_BUILD}"
              echo "‚è≥ Paper pas encore sur ${VANILLA}, dernier build: ${OLD_BUILD}"
            else
              PAPER=$(jq -r '.paper // empty' versions.json.bak)
              echo "‚è≥ Paper pas encore sur ${VANILLA}, aucun build trouv√©"
            fi
          else
            PAPER=$(jq -r '.paper // empty' versions.json.bak)
            echo "‚úÖ Paper inchang√©: ${PAPER}"
          fi

          compare "paper" "$PAPER"
          echo "::endgroup::"

          # ============================================
          # 3. Fabric
          # ============================================
          echo "::group::Checking Fabric"
          FABRIC=""

          FABRIC_GAME=$(curl -fsSL "https://meta.fabricmc.net/v2/versions/game" \
            | jq -r --arg v "$VANILLA" '.[] | select(.version == $v) | .version // empty')
          FABRIC_LOADER=$(curl -fsSL https://meta.fabricmc.net/v2/versions/loader \
            | jq -r '.[0].version // empty')

          if [ -n "$FABRIC_GAME" ] && [ -n "$FABRIC_LOADER" ]; then
            FABRIC="${VANILLA}-loader.${FABRIC_LOADER}"
            if [ "$VANILLA_CHANGED" = true ]; then
              CHANGES="${CHANGES}fabric,"
              echo "‚úÖ Fabric supporte ${VANILLA} ‚Üí loader ${FABRIC_LOADER}"
            else
              MINOR_UPDATES="${MINOR_UPDATES}fabric,"
              echo "üîß Fabric update mineur ‚Üí loader ${FABRIC_LOADER}"
            fi
          elif [ "$VANILLA_CHANGED" = true ]; then
            LAGGING="${LAGGING}fabric,"
            OLD_FABRIC_GAME=$(curl -fsSL "https://meta.fabricmc.net/v2/versions/game" \
              | jq -r --arg v "$OLD_VANILLA" '.[] | select(.version == $v) | .version // empty')
            if [ -n "$OLD_FABRIC_GAME" ]; then
              FABRIC="${OLD_VANILLA}-loader.${FABRIC_LOADER}"
              echo "‚è≥ Fabric pas encore sur ${VANILLA}, reste sur ${OLD_VANILLA}"
            else
              FABRIC=$(jq -r '.fabric // empty' versions.json.bak)
              echo "‚è≥ Fabric pas encore sur ${VANILLA}, aucune info"
            fi
          else
            FABRIC=$(jq -r '.fabric // empty' versions.json.bak)
            echo "‚úÖ Fabric inchang√©: ${FABRIC}"
          fi

          compare "fabric" "$FABRIC"
          echo "::endgroup::"

          # ============================================
          # 4. Forge
          # ============================================
          echo "::group::Checking Forge"
          FORGE=""

          FORGE_DATA=$(curl -fsSL \
            "https://files.minecraftforge.net/net/minecraftforge/forge/promotions_slim.json" 2>/dev/null || echo "{}")
          FORGE_VERSION=$(echo "$FORGE_DATA" | jq -r \
            --arg v "$VANILLA" '.promos[$v+"-recommended"] // .promos[$v+"-latest"] // empty')

          if [ -n "$FORGE_VERSION" ]; then
            FORGE="${VANILLA}-${FORGE_VERSION}"
            if [ "$VANILLA_CHANGED" = true ]; then
              CHANGES="${CHANGES}forge,"
              echo "‚úÖ Forge supporte ${VANILLA} ‚Üí ${FORGE_VERSION}"
            else
              MINOR_UPDATES="${MINOR_UPDATES}forge,"
              echo "üîß Forge update mineur ‚Üí ${FORGE_VERSION}"
            fi
          elif [ "$VANILLA_CHANGED" = true ]; then
            LAGGING="${LAGGING}forge,"
            OLD_FORGE=$(echo "$FORGE_DATA" | jq -r \
              --arg v "$OLD_VANILLA" '.promos[$v+"-recommended"] // .promos[$v+"-latest"] // empty')
            if [ -n "$OLD_FORGE" ]; then
              FORGE="${OLD_VANILLA}-${OLD_FORGE}"
              echo "‚è≥ Forge pas encore sur ${VANILLA}, reste sur ${OLD_VANILLA}-${OLD_FORGE}"
            else
              FORGE=$(jq -r '.forge // empty' versions.json.bak)
              echo "‚è≥ Forge pas encore sur ${VANILLA}, aucune info"
            fi
          else
            FORGE=$(jq -r '.forge // empty' versions.json.bak)
            echo "‚úÖ Forge inchang√©: ${FORGE}"
          fi

          compare "forge" "$FORGE"
          echo "::endgroup::"

          # ============================================
          # 5. NeoForge
          # ============================================
          echo "::group::Checking NeoForge"
          NEOFORGE=""

          # NeoForge utilise le format MAJEUR.MINEUR.PATCH bas√© sur la MC
          # Ex: MC 1.21.4 ‚Üí NeoForge 21.4.x
          MC_MAJOR=$(echo "$VANILLA" | cut -d. -f2)
          MC_MINOR=$(echo "$VANILLA" | cut -d. -f3)
          MC_MINOR=${MC_MINOR:-0}
          NEO_PREFIX="${MC_MAJOR}.${MC_MINOR}"

          NEO_DATA=$(curl -fsSL \
            "https://maven.neoforged.net/releases/net/neoforged/neoforge/maven-metadata.xml" 2>/dev/null || echo "")
          NEO_VERSION=$(echo "$NEO_DATA" | grep -oP "<version>${NEO_PREFIX}\.[0-9]+</version>" \
            | grep -oP "${NEO_PREFIX}\.[0-9]+" | sort -V | tail -1)

          if [ -n "$NEO_VERSION" ]; then
            NEOFORGE="$NEO_VERSION"
            if [ "$VANILLA_CHANGED" = true ]; then
              CHANGES="${CHANGES}neoforge,"
              echo "‚úÖ NeoForge supporte ${VANILLA} ‚Üí ${NEO_VERSION}"
            else
              MINOR_UPDATES="${MINOR_UPDATES}neoforge,"
              echo "üîß NeoForge update mineur ‚Üí ${NEO_VERSION}"
            fi
          elif [ "$VANILLA_CHANGED" = true ]; then
            LAGGING="${LAGGING}neoforge,"
            OLD_MC_MAJOR=$(echo "$OLD_VANILLA" | cut -d. -f2)
            OLD_MC_MINOR=$(echo "$OLD_VANILLA" | cut -d. -f3)
            OLD_MC_MINOR=${OLD_MC_MINOR:-0}
            OLD_NEO_PREFIX="${OLD_MC_MAJOR}.${OLD_MC_MINOR}"
            OLD_NEO_VERSION=$(echo "$NEO_DATA" | grep -oP \
              "<version>${OLD_NEO_PREFIX}\.[0-9]+</version>" \
              | grep -oP "${OLD_NEO_PREFIX}\.[0-9]+" | sort -V | tail -1)
            if [ -n "$OLD_NEO_VERSION" ]; then
              NEOFORGE="$OLD_NEO_VERSION"
              echo "‚è≥ NeoForge pas encore sur ${VANILLA}, reste sur ${OLD_NEO_VERSION}"
            else
              NEOFORGE=$(jq -r '.neoforge // empty' versions.json.bak)
              echo "‚è≥ NeoForge pas encore sur ${VANILLA}, aucune info"
            fi
          else
            NEOFORGE=$(jq -r '.neoforge // empty' versions.json.bak)
            echo "‚úÖ NeoForge inchang√©: ${NEOFORGE}"
          fi

          compare "neoforge" "$NEOFORGE"
          echo "::endgroup::"

          # ============================================
          # 6. Spigot
          # ============================================
          echo "::group::Checking Spigot"
          SPIGOT=""

          SPIGOT_DATA=$(curl -fsSL \
            "https://hub.spigotmc.org/versions/${VANILLA}.json" 2>/dev/null || echo "{}")
          SPIGOT_REF=$(echo "$SPIGOT_DATA" | jq -r '.refs.BuildData // empty')

          if [ -n "$SPIGOT_REF" ]; then
            SPIGOT="${VANILLA}-${SPIGOT_REF:0:7}"
            if [ "$VANILLA_CHANGED" = true ]; then
              CHANGES="${CHANGES}spigot,"
              echo "‚úÖ Spigot supporte ${VANILLA} ‚Üí ref ${SPIGOT_REF:0:7}"
            else
              MINOR_UPDATES="${MINOR_UPDATES}spigot,"
              echo "üîß Spigot update mineur ‚Üí ref ${SPIGOT_REF:0:7}"
            fi
          elif [ "$VANILLA_CHANGED" = true ]; then
            LAGGING="${LAGGING}spigot,"
            OLD_SPIGOT_DATA=$(curl -fsSL \
              "https://hub.spigotmc.org/versions/${OLD_VANILLA}.json" 2>/dev/null || echo "{}")
            OLD_SPIGOT_REF=$(echo "$OLD_SPIGOT_DATA" | jq -r '.refs.BuildData // empty')
            if [ -n "$OLD_SPIGOT_REF" ]; then
              SPIGOT="${OLD_VANILLA}-${OLD_SPIGOT_REF:0:7}"
              echo "‚è≥ Spigot pas encore sur ${VANILLA}, reste sur ${OLD_VANILLA}"
            else
              SPIGOT=$(jq -r '.spigot // empty' versions.json.bak)
              echo "‚è≥ Spigot pas encore sur ${VANILLA}, aucune info"
            fi
          else
            SPIGOT=$(jq -r '.spigot // empty' versions.json.bak)
            echo "‚úÖ Spigot inchang√©: ${SPIGOT}"
          fi

          compare "spigot" "$SPIGOT"
          echo "::endgroup::"

          # ============================================
          # 7. Vanilla changed ‚Üí toujours dans CHANGES
          # ============================================
          if [ "$VANILLA_CHANGED" = true ]; then
            CHANGES="vanilla,snapshot,${CHANGES}"
          elif [ "$(jq -r '.snapshot // empty' versions.json.bak)" != "$SNAPSHOT" ]; then
            MINOR_UPDATES="${MINOR_UPDATES}snapshot,"
          fi

          # ============================================
          # 8. Construire le VERSION_MAP
          # ============================================
          build_map() {
            local key="$1"
            local new_val="$2"
            local old_val
            old_val=$(jq -r ".${key} // empty" versions.json.bak)
            if [ -n "$new_val" ]; then
              echo "${key}:${old_val:-inconnu}‚Üí${new_val}"
            fi
          }

          VERSION_MAP=$(printf "%s\n" \
            "$(build_map "vanilla"  "$VANILLA")" \
            "$(build_map "snapshot" "$SNAPSHOT")" \
            "$(build_map "paper"    "$PAPER")" \
            "$(build_map "fabric"   "$FABRIC")" \
            "$(build_map "forge"    "$FORGE")" \
            "$(build_map "neoforge" "$NEOFORGE")" \
            "$(build_map "spigot"   "$SPIGOT")" \
          )

          # Nettoyer les lignes vides
          VERSION_MAP=$(echo "$VERSION_MAP" | grep -v '^$')

          # ============================================
          # 9. Outputs
          # ============================================
          {
            echo "has_new=${HAS_NEW}"
            echo "vanilla=${VANILLA}"
            echo "old_vanilla=${OLD_VANILLA}"
            echo "vanilla_changed=${VANILLA_CHANGED}"
            echo "changes=${CHANGES%,}"
            echo "lagging=${LAGGING%,}"
            echo "minor_updates=${MINOR_UPDATES%,}"
            echo "version_map<<EOF"
            echo "$VERSION_MAP"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          echo ""
          echo "========== R√âSUM√â =========="
          echo "HAS_NEW       : $HAS_NEW"
          echo "VANILLA       : $OLD_VANILLA ‚Üí $VANILLA"
          echo "CHANGES       : ${CHANGES%,}"
          echo "LAGGING       : ${LAGGING%,}"
          echo "MINOR_UPDATES : ${MINOR_UPDATES%,}"
          echo "VERSION_MAP   :"
          echo "$VERSION_MAP"
          echo "============================"

# ============================================
# 2. G√©n√©ratoin du r√©sum√© pour le PR et la notification
# ============================================
      - name: Generate Summary
        if: steps.check.outputs.has_new == 'true'
        run: |
          VANILLA="${{ steps.check.outputs.vanilla }}"
          OLD_VANILLA="${{ steps.check.outputs.old_vanilla }}"
          VANILLA_CHANGED="${{ steps.check.outputs.vanilla_changed }}"
          LAGGING="${{ steps.check.outputs.lagging }}"
          VERSION_MAP="${{ steps.check.outputs.version_map }}"

          # En-t√™te
          if [ "$VANILLA_CHANGED" = "true" ]; then
            echo "# üÜï Nouvelle MC : ${OLD_VANILLA} ‚Üí ${VANILLA}" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "# üîß Updates mineurs loaders" >> "$GITHUB_STEP_SUMMARY"
          fi

          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Tableau des versions
          echo "| Loader | Ancienne | Nouvelle | Statut |" >> "$GITHUB_STEP_SUMMARY"
          echo "|--------|----------|----------|--------|" >> "$GITHUB_STEP_SUMMARY"

          while IFS= read -r line; do
            [ -z "$line" ] && continue

            KEY=$(echo "$line" | awk -F: '{print $1}')
            OLD_V=$(echo "$line" | awk -F: '{print $2}' | awk -F'‚Üí' '{print $1}')
            NEW_V=$(echo "$line" | awk -F: '{print $2}' | awk -F'‚Üí' '{print $2}')

            # D√©terminer le statut
            if echo ",${LAGGING}," | grep -q ",${KEY},"; then
              STATUS="‚è≥ Attend ${VANILLA}"
            elif [ "$OLD_V" = "$NEW_V" ]; then
              STATUS="‚úÖ Inchang√©"
            elif [ "$VANILLA_CHANGED" = "true" ] && [ "$KEY" != "snapshot" ]; then
              STATUS="‚úÖ Mis √† jour"
            else
              STATUS="üîß Update mineur"
            fi

            echo "| \`${KEY}\` | \`${OLD_V}\` | \`${NEW_V}\` | ${STATUS} |" >> "$GITHUB_STEP_SUMMARY"
          done <<< "$VERSION_MAP"

          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Alertes
          if [ -n "$LAGGING" ]; then
            echo "> [!WARNING]" >> "$GITHUB_STEP_SUMMARY"
            echo "> Loaders en attente de **${VANILLA}** : \`${LAGGING}\`" >> "$GITHUB_STEP_SUMMARY"
            echo "> Le workflow repassera dans 6h." >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
          fi

          echo "---" >> "$GITHUB_STEP_SUMMARY"
          echo "*Prochain check dans 6h ‚Ä¢ [Voir les PRs](/${{ github.repository }}/pulls)*" >> "$GITHUB_STEP_SUMMARY"

      # ============================================
      # Commit versions.json
      # ============================================
      - name: Commit versions.json
        if: steps.check.outputs.has_new == 'true'
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add versions.json
          git diff --cached --quiet || git commit -m \
            "chore: update versions.json [$(date -u +%Y-%m-%d)]"

      # ============================================
      # Pull Request
      # ============================================
      - name: Create Pull Request
        if: steps.check.outputs.has_new == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "chore: update MC versions [automated]"
          title: |
            ${{ steps.check.outputs.vanilla_changed == 'true'
              && format('üÜï Nouvelle MC : {0} ‚Üí {1}', steps.check.outputs.old_vanilla, steps.check.outputs.vanilla)
              || 'üîß Updates mineurs loaders' }}
          body: |
            ## üéÆ R√©sum√© des changements

            ${{ steps.check.outputs.vanilla_changed == 'true'
              && format('üÜï Nouvelle MC : **{0}** ‚Üí **{1}**', steps.check.outputs.old_vanilla, steps.check.outputs.vanilla)
              || '> Pas de nouvelle version MC' }}

            ${{ steps.check.outputs.changes != ''
              && format('## ‚úÖ Mis √† jour\n`{0}`', steps.check.outputs.changes)
              || '' }}

            ${{ steps.check.outputs.lagging != ''
              && format('## ‚è≥ Pas encore sur {0}\nCertains loaders ne supportent pas encore la nouvelle version MC :\n`{1}`\n> Le workflow repassera dans 6h.', steps.check.outputs.vanilla, steps.check.outputs.lagging)
              || '' }}

            ${{ steps.check.outputs.minor_updates != ''
              && format('## üîß Updates mineurs\n`{0}`', steps.check.outputs.minor_updates)
              || '' }}
          branch: "chore/update-mc-versions"
          labels: "mc-versions,automated"
          delete-branch: true

      # ============================================
      # Notification Discord
      # ============================================
      - name: Notify Discord
        if: steps.check.outputs.has_new == 'true'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          if [ -z "$DISCORD_WEBHOOK" ]; then
            echo "Pas de webhook Discord configur√©, skip."
            exit 0
          fi

          VANILLA="${{ steps.check.outputs.vanilla }}"
          OLD_VANILLA="${{ steps.check.outputs.old_vanilla }}"
          VANILLA_CHANGED="${{ steps.check.outputs.vanilla_changed }}"
          LAGGING="${{ steps.check.outputs.lagging }}"
          VERSION_MAP="${{ steps.check.outputs.version_map }}"

          # Initialiser les listes par cat√©gorie
          UPDATED_LINES=""
          LAGGING_LINES=""
          MINOR_LINES=""

          # Parser le VERSION_MAP ligne par ligne
          while IFS= read -r line; do
            [ -z "$line" ] && continue

            # Utiliser awk au lieu de cut pour le s√©parateur multi-byte ‚Üí
            KEY=$(echo "$line" | awk -F: '{print $1}')
            OLD_V=$(echo "$line" | awk -F: '{print $2}' | awk -F'‚Üí' '{print $1}')
            NEW_V=$(echo "$line" | awk -F: '{print $2}' | awk -F'‚Üí' '{print $2}')

            if echo ",${LAGGING}," | grep -q ",${KEY},"; then
              LAGGING_LINES="${LAGGING_LINES}‚Ä¢ \`${KEY}\` : \`${OLD_V}\` *(attend \`${VANILLA}\`)*\n"
            elif [ "$VANILLA_CHANGED" = "true" ] && [ "$KEY" != "snapshot" ]; then
              UPDATED_LINES="${UPDATED_LINES}‚Ä¢ \`${KEY}\` : \`${OLD_V}\` ‚Üí \`${NEW_V}\`\n"
            else
              MINOR_LINES="${MINOR_LINES}‚Ä¢ \`${KEY}\` : \`${OLD_V}\` ‚Üí \`${NEW_V}\`\n"
            fi
          done <<< "$VERSION_MAP"

          # Construire les fields Discord avec de vrais retours √† la ligne
          FIELDS="["
          FIRST=true

          add_field() {
            local name="$1"
            local value="$2"
            [ -z "$value" ] && return
            [ "$FIRST" = false ] && FIELDS="${FIELDS},"
            # Convertir les \n litt√©raux en vrais newlines pour Discord
            value=$(printf '%b' "$value" | jq -Rs '.')
            # jq -Rs ajoute des guillemets, on les retire car on les met nous-m√™mes
            value=${value#\"}
            value=${value%\"}
            name=$(echo "$name" | sed 's/"/\\"/g')
            FIELDS="${FIELDS}{\"name\":\"${name}\",\"value\":\"${value}\",\"inline\":false}"
            FIRST=false
          }

          add_field "‚úÖ Mis √† jour" "$(printf '%b' "$UPDATED_LINES")"
          add_field "‚è≥ Pas encore sur ${VANILLA}" "$(printf '%b' "$LAGGING_LINES")"
          add_field "üîß Updates mineurs" "$(printf '%b' "$MINOR_LINES")"

          FIELDS="${FIELDS}]"

          # Couleur et titre selon le sc√©nario
          if [ "$VANILLA_CHANGED" = "true" ] && [ -n "$LAGGING" ]; then
            COLOR=16744448
            TITLE="üÜï Nouvelle MC : ${OLD_VANILLA} ‚Üí ${VANILLA}"
            DESC="Certains loaders ne supportent pas encore ${VANILLA}."
          elif [ "$VANILLA_CHANGED" = "true" ]; then
            COLOR=5814783
            TITLE="üÜï Nouvelle MC : ${OLD_VANILLA} ‚Üí ${VANILLA}"
            DESC="Tous les loaders supportent d√©j√† ${VANILLA} !"
          else
            COLOR=3447003
            TITLE="üîß Updates mineurs loaders"
            DESC="Pas de nouvelle version MC, mais des loaders ont √©t√© mis √† jour."
          fi

          PR_URL="${{ github.server_url }}/${{ github.repository }}/pulls"

          # Construire le JSON proprement avec jq
          PAYLOAD=$(jq -n \
            --arg title "$TITLE" \
            --arg desc "$DESC" \
            --argjson color "$COLOR" \
            --arg url "$PR_URL" \
            --argjson fields "$FIELDS" \
            --arg footer "Minecraft Version Tracker ‚Ä¢ Re-check dans 6h" \
            --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            '{
              embeds: [{
                title: $title,
                description: $desc,
                color: $color,
                url: $url,
                fields: $fields,
                footer: { text: $footer },
                timestamp: $ts
              }]
            }')

          curl -fsSL -X POST "$DISCORD_WEBHOOK" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD"

          echo "‚úÖ Notification Discord envoy√©e"
