# .github/workflows/check-versions.yml
name: üîç Check Minecraft Versions

on:
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check all APIs
        id: check
        run: |
          if [ ! -f versions.json ]; then
            echo '{}' > versions.json
          fi

          OLD_JSON=$(cat versions.json)
          OLD_VANILLA=$(echo "$OLD_JSON" | jq -r '.vanilla // empty')

          VANILLA_CHANGED=false
          UPDATE_TYPE="none"
          CHANGES=""
          LAGGING=""
          MINOR_UPDATES=""

          MANIFEST=$(curl -fsSL https://piston-meta.mojang.com/mc/game/version_manifest_v2.json)
          VANILLA=$(echo "$MANIFEST" | jq -r '.latest.release // empty')
          SNAPSHOT=$(echo "$MANIFEST" | jq -r '.latest.snapshot // empty')

          # 1. Check Vanilla (Sc√©nario Grosse Mise √† Jour)
          if [ "$VANILLA" != "$OLD_VANILLA" ] && [ -n "$VANILLA" ]; then
            VANILLA_CHANGED=true
            UPDATE_TYPE="major"
            CHANGES="vanilla"
            jq --arg v "$VANILLA" '.["vanilla"] = $v' versions.json > tmp.json && mv tmp.json versions.json
            echo "üÜï Nouvelle version Minecraft d√©tect√©e: ${VANILLA}"
          fi

          # Fonction de tri intelligente
          check_status() {
            local key="$1"
            local new_val="$2"
            local old_val=$(echo "$OLD_JSON" | jq -r ".${key} // empty")

            if [ "$VANILLA_CHANGED" = true ]; then
              if [ -n "$new_val" ] && [ "$new_val" != "$old_val" ]; then
                CHANGES="${CHANGES},${key}"
                jq --arg k "$key" --arg v "$new_val" '.[$k] = $v' versions.json > tmp.json && mv tmp.json versions.json
              else
                LAGGING="${LAGGING},${key}"
              fi
            else
              if [ -n "$new_val" ] && [ "$new_val" != "$old_val" ]; then
                MINOR_UPDATES="${MINOR_UPDATES},${key}"
                jq --arg k "$key" --arg v "$new_val" '.[$k] = $v' versions.json > tmp.json && mv tmp.json versions.json
                UPDATE_TYPE="minor"
              fi
            fi
          }

          # 2. Snapshot 
          OLD_SNAP=$(echo "$OLD_JSON" | jq -r '.snapshot // empty')
          if [ -n "$SNAPSHOT" ] && [ "$SNAPSHOT" != "$OLD_SNAP" ]; then
            MINOR_UPDATES="${MINOR_UPDATES},snapshot"
            jq --arg v "$SNAPSHOT" '.["snapshot"] = $v' versions.json > tmp.json && mv tmp.json versions.json
            if [ "$UPDATE_TYPE" = "none" ]; then UPDATE_TYPE="minor"; fi
          fi

          # 3. Paper
          PAPER_BUILDS=$(curl -fsSL "https://api.papermc.io/v2/projects/paper/versions/${VANILLA}/builds" 2>/dev/null || echo "{}")
          PAPER_BUILD=$(echo "$PAPER_BUILDS" | jq -r '.builds[-1]?.build // empty')
          PAPER=""
          if [ -n "$PAPER_BUILD" ]; then PAPER="${VANILLA}-build.${PAPER_BUILD}"; fi
          check_status "paper" "$PAPER"

          # 4. Fabric
          FABRIC_LOADER=$(curl -fsSL "https://meta.fabricmc.net/v2/versions/loader" | jq -r '.[0].version // empty')
          FABRIC_GAME=$(curl -fsSL "https://meta.fabricmc.net/v2/versions/game" | jq -r '[.[] | select(.stable==true)][0].version // empty')
          FABRIC=""
          if [ -n "$FABRIC_LOADER" ] && [ "$FABRIC_GAME" = "$VANILLA" ]; then FABRIC="${VANILLA}-loader.${FABRIC_LOADER}"; fi
          check_status "fabric" "$FABRIC"

          # 5. Forge
          FORGE_PROMOS=$(curl -fsSL "https://files.minecraftforge.net/net/minecraftforge/forge/promotions_slim.json" 2>/dev/null || echo "{}")
          FORGE_REC=$(echo "$FORGE_PROMOS" | jq -r ".promos[\"${VANILLA}-recommended\"] // empty")
          FORGE_LAT=$(echo "$FORGE_PROMOS" | jq -r ".promos[\"${VANILLA}-latest\"] // empty")
          FORGE=""
          if [ -n "$FORGE_REC" ]; then FORGE="$FORGE_REC"; elif [ -n "$FORGE_LAT" ]; then FORGE="$FORGE_LAT"; fi
          check_status "forge" "$FORGE"

          # 6. NeoForge
          MC_PARTS=(${VANILLA//./ })
          MC_MINOR="${MC_PARTS[1]:-0}"
          NEOFORGE_VERSIONS=$(curl -fsSL "https://maven.neoforged.net/api/maven/versions/releases/net/neoforged/neoforge" 2>/dev/null || echo "{}")
          NEOFORGE=$(echo "$NEOFORGE_VERSIONS" | jq -r --arg major "$MC_MINOR" '[.versions[]? | select(startswith($major + ".") and test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))] | sort_by(split(".") | map(tonumber)) | last // empty')
          check_status "neoforge" "$NEOFORGE"

          # 7. Spigot
          SPIGOT_INFO=$(curl -fsSL "https://hub.spigotmc.org/versions/${VANILLA}.json" 2>/dev/null || echo "{}")
          SPIGOT_REF=$(echo "$SPIGOT_INFO" | jq -r '.refs?.Spigot // empty')
          SPIGOT=""
          if [ -n "$SPIGOT_REF" ]; then SPIGOT="${VANILLA}-$(echo "$SPIGOT_REF" | cut -c1-7)"; fi
          check_status "spigot" "$SPIGOT"

          # 8. Nettoyage et Output
          CHANGES=$(echo "$CHANGES" | sed 's/^,//')
          LAGGING=$(echo "$LAGGING" | sed 's/^,//')
          MINOR_UPDATES=$(echo "$MINOR_UPDATES" | sed 's/^,//')

          echo "Type de mise √† jour: $UPDATE_TYPE"
          
          {
            echo "update_type=${UPDATE_TYPE}"
            echo "vanilla=${VANILLA}"
            echo "old_vanilla=${OLD_VANILLA}"
            echo "changes=${CHANGES}"
            echo "lagging=${LAGGING}"
            echo "minor_updates=${MINOR_UPDATES}"
          } >> "$GITHUB_OUTPUT"

      # ============================================
      # NOTIFICATION DISCORD (Ex√©cut√©e AVANT la cr√©ation de la PR)
      # ============================================
      - name: Notify Discord
        if: steps.check.outputs.update_type != 'none'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          VANILLA="${{ steps.check.outputs.vanilla }}"
          OLD_VANILLA="${{ steps.check.outputs.old_vanilla }}"
          UPDATE_TYPE="${{ steps.check.outputs.update_type }}"
          CHANGES="${{ steps.check.outputs.changes }}"
          LAGGING="${{ steps.check.outputs.lagging }}"
          MINOR="${{ steps.check.outputs.minor_updates }}"

          NEW_JSON=$(cat versions.json)
          OLD_JSON=$(git show HEAD:versions.json 2>/dev/null || echo '{}')

          UPDATED_ARR=()
          LAGGING_ARR=()
          MINOR_ARR=()

          if [ "$UPDATE_TYPE" = "major" ]; then
            UPDATED_ARR+=("‚Ä¢ \`vanilla\` : \`${OLD_VANILLA}\` ‚ûî \`${VANILLA}\`")
          fi

          for KEY in paper fabric forge neoforge spigot snapshot; do
            NEW_V=$(echo "$NEW_JSON" | jq -r ".${KEY} // empty")
            OLD_V=$(echo "$OLD_JSON" | jq -r ".${KEY} // empty")
            [ -z "$OLD_V" ] && OLD_V="N/A"

            if echo ",$CHANGES," | grep -q ",$KEY,"; then
              UPDATED_ARR+=("‚Ä¢ \`${KEY}\` : \`${OLD_V}\` ‚ûî \`${NEW_V}\`")
            elif echo ",$LAGGING," | grep -q ",$KEY,"; then
              LAGGING_ARR+=("‚Ä¢ \`${KEY}\` : \`${OLD_V}\` *(attend ${VANILLA})*")
            elif echo ",$MINOR," | grep -q ",$KEY,"; then
              MINOR_ARR+=("‚Ä¢ \`${KEY}\` : \`${OLD_V}\` ‚ûî \`${NEW_V}\`")
            fi
          done

          FIELDS="[]"

          if [ ${#UPDATED_ARR[@]} -gt 0 ]; then
            DESC_UPDATED=$(printf "%s\n" "${UPDATED_ARR[@]}")
            FIELD=$(jq -n --arg name "‚úÖ Mis √† jour" --arg value "$DESC_UPDATED" '{name: $name, value: $value, inline: false}')
            FIELDS=$(echo "$FIELDS" | jq --argjson f "$FIELD" '. + [$f]')
          fi

          DESCRIPTION=""
          if [ ${#LAGGING_ARR[@]} -gt 0 ]; then
            DESC_LAGGING=$(printf "%s\n" "${LAGGING_ARR[@]}")
            FIELD=$(jq -n --arg name "‚è≥ Pas encore sur ${VANILLA}" --arg value "$DESC_LAGGING" '{name: $name, value: $value, inline: false}')
            FIELDS=$(echo "$FIELDS" | jq --argjson f "$FIELD" '. + [$f]')
            DESCRIPTION="Certains loaders ne supportent pas encore ${VANILLA}."
          fi

          if [ ${#MINOR_ARR[@]} -gt 0 ]; then
            DESC_MINOR=$(printf "%s\n" "${MINOR_ARR[@]}")
            FIELD=$(jq -n --arg name "üîß Updates mineurs" --arg value "$DESC_MINOR" '{name: $name, value: $value, inline: false}')
            FIELDS=$(echo "$FIELDS" | jq --argjson f "$FIELD" '. + [$f]')
          fi

          if [ "$UPDATE_TYPE" = "major" ]; then
            TITLE="üÜï Nouvelle MC : ${OLD_VANILLA} ‚ûî ${VANILLA}"
            COLOR=3447003
          else
            TITLE="üîÑ Update des loaders (Version ${VANILLA})"
            COLOR=10181046
          fi

          PAYLOAD=$(jq -n \
            --arg title "$TITLE" \
            --arg desc "$DESCRIPTION" \
            --argjson color "$COLOR" \
            --argjson fields "$FIELDS" \
            '{embeds: [{title: $title, description: $desc, color: $color, fields: $fields, footer: {text: "Minecraft Version Tracker ‚Ä¢ Re-check dans 6h"}}]}')

          curl -s -X POST "$DISCORD_WEBHOOK" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD"

      # ============================================
      # PULL REQUEST (Plac√©e en tout dernier pour ne pas nettoyer le JSON trop t√¥t)
      # ============================================
      - name: Create Pull Request
        if: steps.check.outputs.update_type != 'none'
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "üîÑ Update versions.json"
          title: "üîÑ Update loaders (Minecraft ${{ steps.check.outputs.vanilla }})"
          body: |
            Des mises √† jour ont √©t√© d√©tect√©es et appliqu√©es √† `versions.json`.
            
            **Vanilla:** `${{ steps.check.outputs.vanilla }}`
            **Grosse MAJ (Nouveaux):** ${{ steps.check.outputs.changes }}
            **Updates Mineurs:** ${{ steps.check.outputs.minor_updates }}
            
            *üìå Validez cette PR pour indiquer que vos images Docker ont √©t√© mises √† jour.*
          branch: auto/version-update
          labels: automated,versions